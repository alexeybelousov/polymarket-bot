# Архитектура валидации покупки и продажи по цене

## Переименование стратегий

### buyStrategy
- `'signal'` → остается (покупаем сразу по сигналу)
- `'validated'` → переименовать в `'validate'` (валидируем рынок перед покупкой)

### sellStrategy
- `'signal'` → остается (продаем за 20 сек если сигнал изменился)
- `'hold'` → переименовать в `'price'` (продаем за 20 сек если цена не соответствует позиции)

---

## 1. АРХИТЕКТУРА ВАЛИДАЦИИ ПОКУПКИ (`buyStrategy: 'validate'`)

### Состояния серии при валидации

```
series.validationState: 'validating' | 'validated' | 'rejected' | null
series.validationHistory: [
  { timestamp: Date, price: number, matches: boolean, symbol: '+' | '-' }
]
series.validationEventId: ObjectId  // ID события для обновления
```

### Процесс валидации

#### Шаг 1: Получение сигнала (`onSignal`)

```
1. Получен сигнал (например, RED)
2. Проверка buyStrategy:
   ├─ Если buyStrategy === 'signal'
   │  └─ Сразу вызываем buyStep(series)
   └─ Если buyStrategy === 'validate'
      ├─ Создаем серию БЕЗ покупки
      ├─ Устанавливаем validationState = 'validating'
      ├─ Сохраняем nextMarketSlug (рынок для валидации)
      ├─ Добавляем событие 'validation_started':
      │  └─ message: "Валидирую рынок:"
      └─ Сохраняем ID события в validationEventId
```

#### Шаг 2: Процесс валидации (в `checkSeries` или отдельный процесс)

```
1. Проверка: если validationState === 'validating'
2. Получаем контекст рынка (nextMarketSlug)
3. Проверяем timeToEnd:
   ├─ Если timeToEnd > 60 сек (больше 1 минуты)
   │  └─ Продолжаем валидацию
   └─ Если timeToEnd <= 60 сек (1 минута до конца)
      └─ Принимаем решение (см. Шаг 3)

4. Каждые 30 секунд (или при каждом tick если прошло 30 сек):
   ├─ Получаем цену с Polymarket для nextMarketSlug
   ├─ Определяем соответствует ли цена сигналу:
   │  ├─ Сигнал RED → проверяем цену UP
   │  │  └─ Если price > 0.5 → НЕ соответствует (сигнал отменился)
   │  │  └─ Если price <= 0.5 → соответствует (сигнал подтверждается)
   │  └─ Сигнал GREEN → проверяем цену DOWN
   │     └─ Если price > 0.5 → НЕ соответствует (сигнал отменился)
   │     └─ Если price <= 0.5 → соответствует (сигнал подтверждается)
   │
   ├─ Добавляем запись в validationHistory:
   │  └─ { timestamp, price, matches, symbol: matches ? '+' : '-' }
   │
   └─ Обновляем событие validationEventId:
      └─ message: "Валидирую рынок: +++--++++--+++++..."
         └─ Добавляем новый символ в конец строки
```

#### Шаг 3: Проверка условий покупки

```
1. Проверяем последние 10 записей в validationHistory:
   ├─ Если все 10 одинаковые (все '+' или все '-')
   │  └─ И все соответствуют сигналу (все '+')
   │     └─ ПОКУПАЕМ (вызываем buyStep)
   │
   └─ Если не все одинаковые
      └─ Продолжаем валидацию

2. Проверка времени (за 1 минуту до конца):
   ├─ Если timeToEnd <= 60 сек
   │  ├─ Подсчитываем количество '+' и '-' в последних 10
   │  ├─ Если '+' >= 6 (большинство подтверждает)
   │  │  └─ ПОКУПАЕМ
   │  └─ Если '+' < 6 (большинство не подтверждает)
   │     ├─ Отменяем серию (status = 'cancelled')
   │     ├─ Добавляем событие 'validation_rejected'
   │     └─ Удаляем из activeSeries
```

#### Шаг 4: Покупка после валидации

```
1. Если валидация успешна:
   ├─ Устанавливаем validationState = 'validated'
   ├─ Вызываем buyStep(series)
   ├─ Обновляем событие validationEventId:
   │  └─ message: "Валидирую рынок: +++--++++--+++++... ✅ Покупка"
   └─ Продолжаем обычный процесс торговли
```

---

## 2. АРХИТЕКТУРА ПРОДАЖИ ПО ЦЕНЕ (`sellStrategy: 'price'`)

### Процесс продажи

#### Текущая логика (`sellStrategy: 'signal'`)

```
За 20 сек до конца:
├─ Проверяем сигнальный рынок
├─ Если currentColor !== series.signalColor
│  └─ Вызываем cancelSignal() (продаем все позиции)
└─ Если currentColor === series.betColor (наш цвет)
   └─ Вызываем sellHedge() (продаем хедж)
```

#### Новая логика (`sellStrategy: 'price'`)

```
За 20 сек до конца:
├─ Получаем цену с Polymarket для currentMarketSlug
├─ Определяем соответствует ли цена нашей позиции:
│  ├─ Мы купили на betColor (например, GREEN)
│  │  └─ Проверяем цену DOWN
│  │     ├─ Если price > 0.5 → НЕ соответствует (рынок против нас)
│  │     │  └─ Вызываем cancelSignal() или sellHedge()
│  │     └─ Если price <= 0.5 → соответствует (рынок за нас)
│  │        └─ НЕ продаем, держим до конца
│  │
│  └─ Мы купили на betColor RED
│     └─ Проверяем цену UP
│        ├─ Если price > 0.5 → НЕ соответствует (рынок против нас)
│        │  └─ Вызываем cancelSignal() или sellHedge()
│        └─ Если price <= 0.5 → соответствует (рынок за нас)
│           └─ НЕ продаем, держим до конца
```

---

## 3. СТРУКТУРА ДАННЫХ

### TradeSeries - новые поля

```javascript
{
  // ... существующие поля ...
  
  // Валидация покупки
  validationState: {
    type: String,
    enum: ['validating', 'validated', 'rejected'],
    default: null
  },
  validationHistory: [{
    timestamp: Date,
    price: Number,
    matches: Boolean,  // соответствует ли цена сигналу
    symbol: String     // '+' или '-'
  }],
  validationEventId: ObjectId,  // ID события для обновления
  validationMarketSlug: String, // Рынок который валидируем
  
  // Для продажи по цене
  // (не нужно новых полей, используем существующие)
}
```

---

## 4. ПРОЦЕСС ВАЛИДАЦИИ (детально)

### Инициализация валидации

```
onSignal() → buyStrategy === 'validate':
├─ Создаем серию со статусом 'active'
├─ validationState = 'validating'
├─ validationMarketSlug = nextMarketSlug
├─ validationHistory = []
├─ Добавляем событие:
│  └─ type: 'validation_started'
│     message: "Валидирую рынок:"
│     validationEventId = event._id
└─ НЕ вызываем buyStep()
```

### Проверка валидации (в `checkSeries`)

```
checkSeries(series):
├─ Если validationState === 'validating':
│  ├─ Получаем контекст для validationMarketSlug
│  ├─ Проверяем timeToEnd:
│  │  ├─ Если timeToEnd > 60 сек
│  │  │  └─ Проверяем прошло ли 30 сек с последней проверки
│  │  │     └─ Если да → выполняем проверку цены
│  │  └─ Если timeToEnd <= 60 сек
│  │     └─ Принимаем решение (покупаем или отменяем)
│  │
│  ├─ Проверка цены (каждые 30 сек):
│  │  ├─ Получаем цену с Polymarket
│  │  ├─ Определяем matches (соответствует ли сигналу)
│  │  ├─ Добавляем в validationHistory
│  │  └─ Обновляем событие validationEventId
│  │
│  └─ Проверка условий покупки:
│     ├─ Если последние 10 записей все '+' → покупаем
│     └─ Если timeToEnd <= 60 и большинство '+' → покупаем
│
└─ Если validationState !== 'validating':
   └─ Продолжаем обычную логику
```

### Логика определения соответствия цены

```
Функция: checkPriceMatchesSignal(price, signalColor, betOutcome)

Сигнал RED → проверяем цену UP:
├─ Если price > 0.5
│  └─ matches = false (сигнал отменился, рынок ушел в GREEN)
└─ Если price <= 0.5
   └─ matches = true (сигнал подтверждается, рынок RED)

Сигнал GREEN → проверяем цену DOWN:
├─ Если price > 0.5
│  └─ matches = false (сигнал отменился, рынок ушел в RED)
└─ Если price <= 0.5
   └─ matches = true (сигнал подтверждается, рынок GREEN)
```

---

## 5. ПРОЦЕСС ПРОДАЖИ ПО ЦЕНЕ (детально)

### Изменения в `checkSeries`

```
Текущая логика (sellStrategy === 'signal'):
├─ Проверка отмены сигнала (строка 1058)
│  └─ Если currentColor !== series.signalColor → cancelSignal()
└─ Проверка продажи хеджа (строка 1106)
   └─ Если currentColor === series.betColor → sellHedge()

Новая логика (sellStrategy === 'price'):
├─ Проверка отмены по цене (за 20 сек)
│  ├─ Получаем цену для currentMarketSlug
│  ├─ Определяем соответствует ли цена позиции
│  └─ Если НЕ соответствует → cancelSignal() или sellHedge()
└─ Проверка продажи хеджа по цене (за 20 сек)
   ├─ Получаем цену для хеджа (nextMarketSlug)
   ├─ Определяем соответствует ли цена позиции
   └─ Если НЕ соответствует → sellHedge()
```

### Логика определения соответствия цены позиции

```
Функция: checkPriceMatchesPosition(price, betColor, betOutcome)

Мы купили на GREEN (betColor = 'green', betOutcome = 'up'):
├─ Проверяем цену DOWN
├─ Если price > 0.5
│  └─ matches = false (рынок против нас, нужно продать)
└─ Если price <= 0.5
   └─ matches = true (рынок за нас, держим)

Мы купили на RED (betColor = 'red', betOutcome = 'down'):
├─ Проверяем цену UP
├─ Если price > 0.5
│  └─ matches = false (рынок против нас, нужно продать)
└─ Если price <= 0.5
   └─ matches = true (рынок за нас, держим)
```

---

## 6. ВРЕМЕННАЯ ДИАГРАММА ВАЛИДАЦИИ

```
Время: 0:00 ──────────────────────────────────────────> 15:00 (закрытие рынка)
       │                                                  │
       │  Получен сигнал RED на рынок 15:00              │
       │  ├─ validationState = 'validating'              │
       │  └─ Событие: "Валидирую рынок:"                 │
       │                                                  │
       │  0:30 - Проверка 1: price = $0.48 → '+'         │
       │  └─ "Валидирую рынок: +"                        │
       │                                                  │
       │  1:00 - Проверка 2: price = $0.49 → '+'         │
       │  └─ "Валидирую рынок: ++"                       │
       │                                                  │
       │  1:30 - Проверка 3: price = $0.52 → '-'        │
       │  └─ "Валидирую рынок: ++-"                       │
       │                                                  │
       │  ... (продолжаем каждые 30 сек)                 │
       │                                                  │
       │  14:00 - timeToEnd = 60 сек                     │
       │  └─ Проверяем последние 10: "++--++++--"       │
       │     └─ Большинство '+' → ПОКУПАЕМ               │
       │                                                  │
       └──────────────────────────────────────────────────┘
```

---

## 7. ВОПРОСЫ ДЛЯ УТОЧНЕНИЯ

1. **Интервал проверки:**
   - Каждые 30 секунд или при каждом `tick()` (каждые 5 сек)?
   - Нужно ли ограничение "не чаще чем раз в 30 сек"?

2. **Условие покупки:**
   - 10 одинаковых символов подряд ИЛИ 10 последних одинаковых?
   - Что если за 1 минуту до конца у нас только 5 проверок?

3. **Отмена валидации:**
   - Что делать если за 1 минуту до конца большинство не подтверждает?
   - Отменять серию полностью или просто не покупать?

4. **Продажа по цене:**
   - Для Step 1 (отмена сигнала) - проверяем цену текущего рынка?
   - Для хеджа - проверяем цену хеджа (nextMarketSlug)?

5. **Хранение истории:**
   - Сколько записей хранить в `validationHistory`?
   - Нужно ли ограничение по времени (например, только последние 10 минут)?

---

## 8. ПРЕИМУЩЕСТВА АРХИТЕКТУРЫ

1. **Гибкость:**
   - Можно легко добавить более сложную логику валидации
   - Можно использовать order book в будущем

2. **Прозрачность:**
   - История валидации видна в таймлайне
   - Можно анализировать качество валидации

3. **Расширяемость:**
   - Легко добавить новые критерии валидации
   - Можно комбинировать несколько проверок

4. **Совместимость:**
   - Старая логика (`buyStrategy: 'signal'`) продолжает работать
   - Можно использовать разные стратегии для разных ботов

